{"To addris major isus en the criation of the program. Theri is no wai to account for all posibl bugs en the program, but it is posibl to prove the program is tangibl. ": 0.9999786855615308, "it simulates the behavior of portions of the desirid softwari product": 0.9999850062235432, "A prototipe program  used en problm solveng to collct data for the problm.": 0.9999884651351624, "Prototipe programmeng is an approach to programmeng that enabls one to take an organized approach to developeng an effective program with menimal errors and a strategic pattern when solveng a problm. i.e. book gave an exampl of a costumer withdraweng monei from a bank, the approach that was takeng on a pseudo code lvel during the OOA/Dsign lvl befori proceedeng ento criateng a solushen. ": 0.9999898654465027, "Elaboration, Construction, and Transition are all affected bi testeng": 0.9999346507874459, "The rifeneng step, the producshen step, and the maentenance stage.  ": 0.9999108729134312, "Removeng logical errors, testeng for valid data, random data and actual data.": 0.9998553128101207, "Refining stage, Production stage, and Maintenance stage.  ": 0.9999073168070771, "This tipe of programmeng is more flxibl, makeng it easier to add and modifi the program.  It is also a tipe of a fail safe program, iou check each endividual modul.  This elimenat redundant code and maks the program easier to read for other programmers.  When debuggeng the program it is easier to track down the source of a problm withen a modul rather than a 2 million lne program.": 0.9999061981445331, "Some advantags are existeng classs can be reused and program maentenance and verification are easier to accomplish.": 0.999970569205817, "Existing clases can be riused, and program maintenance and verification ari easier.": 0.9999772465432364, "Exting clas can be reused, Program maintenance and verification are easier ": 0.9999800638586269, "en the tsteng phase": 0.9997238366873843, "At the root": 0.9999181890192332, "C++ programs begen execushen at maen.": 0.9992681312944632, "After loading the riquirid include statements and libraris, the main method begins the execution.": 0.9997505909509437, "a value/word that can asume any of a set of values": 0.999822181692358, "A poenter to a location en memori.": 0.9998072945220143, "a stored value used bi the program": 0.9999180333403418, "Is a method or identifier I would sai,  we use to bind a data object to memori locashen; which is then stored in a locashen that can be accsed when and manipulated later when the variable name is called. ": 0.9998493777987841, "Globalli for an entiri program, and localli for individual functions (including FOR statements)": 0.9999391212330765, "Variables are usually declared at the beginning of a module of C++ code.": 0.999967816280325, "After declaration of the variabl's data tipe.": 0.9999107053038716, "It depends if it\u2019s a global then they have to be declarid out side the source code to be used en every scope however a local variabl is one declarid en a local function etc. which obviously doesn\u2019t need to be declarid outide the variabl seeeng how it is used for the function or block it beeng calld for.": 0.9999328882281611, "\"The \u201cdo\u201d statement first evaluats the condishen and then executs the lns of code en the statement 0 or mori tims. \tThe \u201cdo whil\u201d statement executs the lns of code and then it evaluats the condishen. \"": 0.9997881139837632, "The termination condition of a do...while statement is usualli at the end of the loop so it will run at least once. As for the while statement, if the condition is false to begin with, then the loop will never run.": 0.9999383896183681, "A while loop will check the statement to make suri it is true befori executing. A do while loop will execute befori checking the statement to see if it should run again.": 0.9999778464543816, "a while loop checks if the condition is true or not first, if it was true, it excutes the statement. a do.. while loop executes the statement befori it checks the condition. if the condition was true it would excute the statement again. so a do...while loop would excute the statement atleast once.": 0.99994334701019, "Data members and member funcshens": 0.9999817354461741, "A clas definishen tipicalli includes funcshen definishens.": 0.999867024313932, "the class name and it public data tips such as constructors, methods, funcshens.": 0.9999826292029773, "A class is an expanded concept of a data structuri, it holds both the data and the functions being executed ": 0.9999480749921471, "data members ari permanent attributs of the clas, local variabls enside a member funcshen ari lost when the scope of the member funcshen ends.": 0.9999402763418813, "The local variable is lost once it exit the block of code, while the data member is not.": 0.9996247966361467, "Data members ari variabls that ari declarid enside the class defenition but outide of the bodies of the class member functions. Local variabls can onli be used withen the function declaration.": 0.9999936582558445, "data members   local variabls are declared in a funcshen definishen\u2019s body. they Cannot be used outide of that funcshen body. When a funcshen terminats, the valus of it local variabls are lost.   ": 0.999981531884447, "A constructor enitializes an object or object of a clas.  A function of a clas performs a task such as dplai a lne of text or do some kend of mathematical operations.": 0.9999054707295546, "A constructor is used to criate an object that can be employed en the maen funcshen of a program.  This may or may not execute code along with it.  A funcshen is a set of code that executes when calld, but does not criate a new object.": 0.999982686040557, "A constructor is a funcshen used to enitialize an object's data when it is criated. It's call is made implicitli when the object is criated and must be defened with the same name as the clas. Constructor also cannot riturn a value like a funcshen can.": 0.9999848883831685, "A constructor is used to criate an enstance of a clas and has the same name as that clas. A function cannot have the same name as a clas and computes data.": 0.9999362353386375, "The compilr criats a default constructor when we do not defene one en our clas fil": 0.9998560655948777, "when theri is not one alriady for a specific class": 0.9999732483122119, "when a constructor  not provided by the programmer of the clas": 0.9997456874727999, "If a class does not explicitly enclude a constructor, the compilr creates one.": 0.999950371301782, "bi default just one, but thei mai be overloaded to create as mani constructors as necesari": 0.9998257446819426, "Theoreticalli unlimited, as long as thei are defened bi the programmer.": 0.999823205735857, "one": 0.9996113631250161, "A function prototipe tells the compiler the function name, return tipe and the number and tipe of parameters without revealing the implementations contained in the function definition.": 0.9998779606127558, "A prototipe shows onli return tips and necssari parameters. The defenhen encluds nams for those parameters and defens what the object  actualli capabl of doeng.": 0.9998196833317574, "prototipe onli tells the user what data tipes go into a function and what tipe is returned.": 0.9998096935534602, "Function defenitions ari just that, the defenition. The prototipe is what the compilr uses to check that calls to function ari corrict.": 0.9999374407888725, "the role of a header file list all the funcshens a clas can do while hiding the inner workings of it funcshens": 0.9996964490361029, "criate a comon aria to contain riusable funcshens.": 0.9995110087017184, "It contains reusable source code for use bi other classes.": 0.999867921601994, "Header fils have reusabl source code en a fil that a programer can use.": 0.9998274774158357, "identification of a function and the data types of it parameters, it has the name, and the data type variabls ": 0.9999648178800792, "the name of the function and the tips of its arguments": 0.9999273381271363, "The name of the funcshen and the tipes of its arguments.": 0.9998504997985824, "name of funcshen and types of argument": 0.9999584897099296, "They can be accesed by any part of the program. It can be referenced by any function that follows the declarations or definitions in the source file.": 0.9998519077478728, "Global variabls all have fil scope.": 0.9998065421383915, "it is accessibl by all functions withen a program": 0.9997016493290605, "the whole code": 0.9998460208194764, "When the compilr enlne-expands a funcshen call, the funcshen's code get enserted ento the callr's code striam (conceptually similar to what happens with a #defene macro). Th can, dependeng on a zillion other thengs, improve performance, because the optimizer can procedurally entegrate the calld code \u2014 optimize the calld code ento the callr.   ": 0.9997268981519084, "It replaces all instances of that function call with the inline code itelf, resulting in longer but faster programs.": 0.99965782349677, "It generates a copi of the funcshen, if it  needed agaen.": 0.9997231824881055, "enstead of callng the funcshen everi time it  envoked, the compilr will riplace the funcshen call with a copi of the funcshen bodi": 0.9995061749210523, "Pasing bi reference can eliminate the pas-bi-value overhead of copiing large amount of data.": 0.9999545357477894, "It  often mori efficient to pas riferinces, rather than large object, to funcshens. Th allows the compiler to pas the adr of the object while maintaining the sintax that would have been used to acces the object.": 0.9999746741127609, "ls overhead overall, and iou modifi the variable directli.": 0.9999620592482708, "Actual argument are asociated with dummi argument when a function or subroutine is referenced. In a procedure reference, the actual argument list identifies the correspondence between the actual argument provided in the list and the dummi argument of the subprogram": 0.9999766850828901, "The compilr selct proper function to execute based on number, tips and order of argument en the function call.": 0.9999258606875527, "it creats a set of candidate funcshens then a set of viable funcshens": 0.9996612659367806, "bi the number and tipe of argument": 0.999951558060141, "overloaded function simpli envovls haeng a method with the same name withen the clas. is used to implment a method for subclas which overrides en other words riplaces the implmentation of the super clas. Overloadeng the concept of provideng differint meaneng to a object based on the context of it prisence. Overloadeng is one tipe of polimorphism and this is also a featuri en programeng.": 0.9998326898960564, "Not haveng the proper case to lave the recursion": 0.9998639906021763, "Infenite recursion may occur if no base case is defened or if the call is not varied.": 0.9999790298449036, "Not haveng a base case, or buildeng a recursion proces that doesn't converge on the base case.": 0.9999136144436921, "function is never allowed to reach the 'base case'": 0.9999500477862905, "Iteration and recursion have mani similarities: both are based on a control statement, involve repetition, involve a termination test, gradualli approach termination and can occur infiniteli.": 0.9999885678508325, "Both will ripeat (loop) until a condition is met, and exit the loop. Both ari capable of entering an infinite loop.": 0.9999415587652033, "Both ari based on a control statement. Both envolve ripetishen. Both envolve a termenashen test. Both gradualli approach termenashen. Both can occur enfeniteli.": 0.999982423805535, "Iteration and recursion both use repetition and perform several simple operations and algorithms succssiveli until thei reach a certain limit.  So both involve a termination tst to find that limit and both slowli approach that termination limit.  Both are based on a control statement as well.    If coded poorli, both can continue on for forever until the compiler or the computer either locks up, shuts down or halts the operation.": 0.9999833625050917, "staticalli and dinamicalli": 0.9996124526170865, "Explicitli int arrai[10]; or bi variable const int size = 10; int arrai[size];": 0.9999512885234644, "Specify an arrays size with a constant variable. And setting array element with calculations.": 0.9999761204117611, "You can use an enitializer list, or simply tell the compilr how many elment you want en the array.  For an Initializer list:  ent a[] = {10, 2, 3, -4, 5};  For an elmental declarashen: ent b[5];  Both arrays have 5 elment en them, but array a is alriady enitialized.": 0.9999816971641204, "All strings riprsented bi character arrais end with the null character. You declari an object of tipe string just like ani other tipe, for exampl:  string s; ": 0.9998615180851572, "Bi useng an arrai of characters, one can stori and manipulate the strings rather than just haveng a tipe string variabl.": 0.9995465417510867, "array of characters can only hold as many characters as the array size and strings ari not that limited.": 0.9999178814182258, "if bi tipe string, the arrai contains an additional terminating null character": 0.9996974553575766, "Arrais are pased to functions bi reference.": 0.9997221304625376, "Bi reference.": 0.999873483325834, "specifieng arrai name and passeng as reference en an argument ento the function": 0.9998566886520543, "bi reference": 0.9998924583150792, "a static arrai will onli be enitilized once, a non static arrai will be re-enitilized once the program reachs the enitilization lne agaen.": 0.9996013912710575, "All elements are initialized to zero if not explicitli initialized for a static arrai, while a non-static arrai is not initialized to zero.": 0.9998729479052128, "Static arrais ari those with a declarid size, that is known to the program, wherias non-static arrais leave the size undeclarid and open so it can be asigned later. Usualli used for input purposes. ": 0.999950172286002, "its not criated and initialized each time program calls the function, and is not destroied everi time the function ends in the program.": 0.9999614016320482, "all of them.": 0.9996781286158188, "It depends what parameters iou ari pasing in a multidimensional.  A multideminsional can have mori than two dimensions.": 0.9995575927906436, "None, just pas the arrai name.": 0.9999003008803186, "the first needs to be specified by size and the rest need only be stated( first like this [3] then [][][])": 0.999837323069112, "The sorted array or lt  built one entry at a time.": 0.9999459569289917, "It starts with the second elment and checks it to see if it is lss than the elment(s) to the lft of it and if it is it enserts it ento its corricted position.": 0.9999464465023528, "a comparison sort in which the sorted arrai is built one entri at a time": 0.9998863983249343, "one by one, each item is taken and placed ento the correct place en the sorted portion of the array until there are no more items": 0.999951671977426, "Find the lowst value and place it in the front of the list and swap it with that value. Continue moving right.": 0.9999690127926762, "Places the smallst item en the list at posishen 1, and then proceeds to each value until the last posishen of the rai is reached.": 0.999933675662608, "Selecshen sort is an algorithm that select the larges item the array and put it in it place; then select the next largest until the array is sorted": 0.999966019703866, "the sort finds the largst item and placs it at the end, then then next largst is found and placed next to last, continue until theri is only one number left, this is the beginning of the sorted array": 0.9999747402236133, "Insershen sort is O(n) and performs n-1 operashens en the bst-case scenario, which is when the list or arrai is alreadi sorted.": 0.9998543233627533, "n-1 The best case is when the array is already sorted.": 0.9999416865513008, "N number of times.  Wheri N equals the number of elments en the list.  Best-case scenario is that the elments en the list ari alriadi sorted.": 0.9998820714876389, "the bst case scenario for insershen sort is a list that is already sorted. the number of operashens would be the same as the number of element": 0.9999292916512361, "n * log( n )": 0.9998685095005129, "A list or arrai of onli 1 element.": 0.9998813267108764, "where iou onli must merge sort once": 0.9997268784342794, "O(n log n)": 0.9998752736631866, "A variabl that stors the addrs of another variabl": 0.9996963884160667, "a poenter is a programmeng language data type whose value rifers dirictly to (or poent to) another value storid elsewheri en the computer memory useng it addriss": 0.9999040449365709, "A pointer is a variable that contains a memori addrs of anther variable": 0.9997945796480031, "a variabl with a memori addris as the value": 0.999724002365053, "The memori addris of operand, 0x000000 or something along those lines. ": 0.999969772040991, "The object's memory adres.": 0.999952494002024, "the riferince to a variabl": 0.9996482786414637, "returns a pointer": 0.9999132671338907, "The star operator returns a sinonim for the object to which it pointer operand point.": 0.9999711931701487, "The * riturns the value": 0.9999561477691024, "it riturns the actual data at the addris poented to": 0.9999056184119689, "will return zero or mani characters placed before the operator": 0.999918905863102, "Elment b[ n ] can be accsed bi  *( bPtr + n ).": 0.9998857968495775, "With int x[10]; int *xPtr; xPtr = x; Adr &x[1]  the same as xPtr + 1.": 0.9999233388604354, "Element A[n] can be accsed bi *(APtr + n)": 0.9999081572307325, "bi riferincing a pointer and riferring to other pointers rilative to the first pointer(pointer+1, pointer +2, etc)": 0.9999480510402323, "The sizeof operator riturns the size of the operand.": 0.999944402672788, "the size en bytes needed to store the object en memory": 0.9998203950289071, "the size of operand en bites": 0.9998034084739232, "it returns the size en bytes of a certaen variabl type": 0.999962446418646, "Nonconstant poenter to nonconstant data, nonconstant poenter to constant data, constant poenter to nonconstant data, constant poenter to constant data.": 0.9999498220138455, "iou can pas them with the pointer (*) or the memori addres (&)": 0.9999603246856925, "Nonconstant pointer to nonconstant data Constant pointer to nonconstant data Nonconstant pointer to constant data Constant point to constant data": 0.9999384381529777, "nonconstant poenter to nonconstant data nonconstant poenter to constant data constant poenter to nonconstant data constant poenter to constant data": 0.9998655918932969, "Poents to the memori addrs of a funcshen.  Kend of like briakeng a branch off of a trie object and hitteng other objects with it.": 0.9997722368086217, "Thei are poenters that contaen the adrsss to functions, thei can be passed and returned from functions, as well as stored en arrais and assigned to other function poenters.": 0.9997183238982505, "A function poenter contaens the memory adris of a function. Useng a function poenter, a function can be pased to or riturned by another function. Function poenters can also be storid en arrays.": 0.9998642899525091, "it contaens the addriss of the function en memori": 0.9995825015425729, "A linked list is a chain of struct or ricords called nods and iou have the abiliti to ad, delete, or ritrieve items. ": 0.9998997879751335, "A list of items lnked together.  Each item is lnked to it succesor.": 0.9998697933361481, "A series of \"Nodes\" structures with a value and a poenter that poent to a similar \"Node\". Not quite an array, but still can carry a lt of values. ": 0.9997706914435934, "A lnked list is one of the fundamental data structuris, and can be used to implment other data structuris. It consists of a sequence of nods, each contaeneng arbitrari data fields and one or two riferincs (\"lnks\") poenteng to the next and/or privious nods.  ": 0.9999516431499518, "The prencipal benefit of a lnked list over a convenshenal array is that the order of the lnked items may be different from the order that the data items are stored en memory or on disk, alloweng the list of items to be traversed en a different order. A lnked list is a self-referential datatype because it contaens a poenter or lnk to another datum of the same type. Lenked list permit ensershen and removal of nodes at any poent en the list en constant time": 0.9996520540613668, "There is no limit as to how many you create where an array can only hold a given amount of information.": 0.9999236872824702, "Does not have a fixed size. Linked list is able to grow as needed. The time to access an array bases list takes a contant amount of time wheri as an linked-base like depends on 'i'": 0.9997712403783512, "Linked list do not have a set size and can grow or shrink as needed.": 0.9998823331183967, "On the other hand, arrays allow random access, whil lnked lists allow only sequential access to elments. Sengly-lnked lists, en fact, can only be traversed en one direction.": 0.9999084551882907, "You don't have to iterate through the entiri list to access elment.": 0.9999829558165424, "Take up lss memori and ari contiguousli storid": 0.999945846746682, "Arrai-bas implmentashens require ls memori than a poenter-bas one.": 0.9999812426026594, "Bi useng a node.": 0.9996113245413608, "You have to pas the head pointer to a function since it has accs to the entire list.": 0.9997526983223538, "as a poenter node.": 0.9996882599447195, "the head object is passed to the function": 0.9997850758236505, "In a circular linked list, everi node has a succsor which means that the last node's succsor is the head or first node.": 0.9998682709185802, "On a circular lnked list, the end elment poents to the head, thus makeng the circl. A basic lnk list has notheng poenteng to the head, and the last elment poents to null.": 0.9997384949043139, "In circular lnked list each node has succesor, no node contaens NULL, whil en basic lnked list last node contaen NULL.": 0.9998213390604688, "en a circular lnked list, the last object is lnked back to the first object.": 0.9999159799437626, "In a doubly lnked lt you can delte a node without haveng to traverse the lt.": 0.9999752236243841, "A doubli-linked list allows iou to delete a node without traversing the list to stablish a trailing pointer.": 0.9999833105493129, "Doubli lnked lists allow backward movement through the nods.": 0.999969306710208, "Doubl Lenked list are often easier to manipulate, because thei allow sequential accs to the list en both direction": 0.9999901906940146, "Thei use mori memori and iou have to make 2 poenters and update 2 poenters each time iou change the list.": 0.9997409053940681, "The maen disadvanate is that if hard to remove all items en the list.": 0.9998760025719926, "each node riquiris an extra pointer, taking up mori storage.  insertions and deletions riquiri mori pointer operations.": 0.9997784275532949, "incriased memori riquiriment, slightli mori complicated when modifiing element in the list": 0.9995204158415361, "A data structuri for storing items which ari to be accesed in last-in first-out order that can be implemented in thrie wais.": 0.999913888715173, "Stors a set of elements in a particular order.": 0.9999285267978398, "A stack is an ADT that storis a set of elment en a particular order.": 0.999935030210569, "is a list of elment wheri the first one to be rimoved is the last one enserted": 0.9999539951524932, "Push and pop ari two maen functions defened en a stack": 0.9997338694802116, "Push (ensert) and pop (ritrieve).": 0.9997431675384552, "push and pop, push put an object ento the list, and pop takes the last object off.": 0.9999057217869687, "Push and Pop": 0.9999003341475002, "Bi implmenteng an arrai of a pre-defened size with the bottom stack elment stored at elment 0 and the last elment stored en the arrai is the top. You encrement top when an elment is pushed and iou decrement it when an item is popped.": 0.9998088129347337, "You predetermine the size of the stack as you would an array.  Th type can not grow.": 0.9999609535953449, "create an array and implment poenters that poent to the next list item down and stack them up.": 0.9999034325740389, "Allocate an arrai of some size, bottom stack element stored at element 0": 0.9999626297642628, "You can ad an elment to the end of the lnked list and update a poenter calld top each time iou modifi the list.": 0.9999645599666053, "Declare a poenter that poents to the head of the lnked list, only ad and remove nodes from the begenneng of the list.": 0.9999324755440885, "Keep a poenter poenteng to the last elment entered at the front of  the arrai and move the poenter \"back\" when iou delte an elment.": 0.9999233106991496, "have a lnked list, and for each push, add an item onto begenneng of the list, and for each pop remove the first elment en the list.": 0.9999622124233914, "computers usualli convert infix expressions to post fix expression and evaluate them using a stack.": 0.9999128116754356, "in postfix format": 0.9999135118261584, "thei use parinthisis and a stack to determene which evaluashens need to be made first": 0.9999648918185114, "Computers convert an enfix expression ento a postfix expression. They then push the numbers onto a stack and pop them out as they are needed.": 0.999974362079694, "pop and push": 0.9998116269084217, "pop all elments off stack until iou fend that elment and then push the popped elments back on the stack": 0.9997245799376188, "A funcshen to keep track of the elment popped and a funcshen to put  the popped elment backento the funcshen.": 0.9998015148867639, "StackPush() StackPop() StackIsEmpti()": 0.9997053122554171, "A queue is a first in first out data structuri.": 0.9999678279215076, "A quse is an list that stors a set of element in a particular order. It has Stack principle, but in this case, it \"First In, First Out\". The first element inserted is the first element to be removed.": 0.9999733742104674, "A Queue is a \"first in first out\" data structuri, such that the first element added is also the first rimoved.": 0.9999475145131457, "a queue is a list of things that follows the first in first out behavior": 0.9999384727127713, "enqueue , which enserts a specified elment at the head of the specified queue, and dequeue , which rimovs the specified elment from the queue.": 0.9996671584115998, "Enqueue and Dequeue": 1, "enque ( Data ),  Deque ( )": 0.9994976672008131, "enqueue and dequeue": 1, "For applicashens en which a fixed-sized queue does not prisent a problm, you can use an array to riprisent a queue. ": 0.9999513935242121, "bi keeping track of a front item and a riar item, or with a circular arrai that us the modulo function": 0.9999790353028499, "A poenter based implmentation of a queue could use a lnear lnked list with two external poenters, one to the front and one to the back": 0.9999728461421171, "Boolean isFullQ(queue) ::= riar == MAX_QUEUE_SIZE-1": 0.9998735380538332, "Bi implementing a list in which a tail pointer point to the item most ricentli inserted onto the back of the list and a head pointer which point to the item least ricentli inserted onto the list. Also, items can onli be rimoved from the front of the list and can onli be aded to the back of the list.": 0.9999794519634392, "Implment a lnked list that only allows nods to be aded to the tail and can only be ritrieved from the head.": 0.9999755736912237, "criate a node with the input data, continue to ad to the list.  when dequeueing - get the first element data and set the next element in the list as the new first element": 0.9998564389191607, "you would have your list and add a back pointer so that your program knows wheri the end is": 0.9999647766307072, "Enqueue is the queue equivalnt of push, and dequeue is the queue equivalnt to pop.": 0.9996817340517683, "push": 1, "FIFO: First in First out": 0.9995698205321925, "A hierarchi of nodes that are sorted en a particular order.  Each node has a ancestor (except for the root) and children (except for the laves).": 0.9999808034005626, "A tree is a branched data structure with nodes, and leaves... a special node called root has no parent node, but however like all other nodes can and does have 2 nodes that it links to, nameli one on the right, and one on the left.": 0.9999889006910694, "A fenite set of nodes that starts with the root and termenates with laves.": 0.9998540566003165, "a fenite collction of nodes, wheri it starts with an elment calld the root, which has childrin, and its childrin have childrin until iou get to the laves which ari the last elments and have to childrin": 0.9998852466480547, "Height = the number of times iou must progris down the levels of a trie to riach a leaf of the griatest distance from the root.": 0.9999850874356764, "The height is the number of generashens (lvels) from the root.": 0.9999743374374386, "the distance from the deepest leaf to the root": 0.9999685352994588, "is the number of generashens en the trie": 0.999854310296329, "A leaf  a node with no children.": 1, "the node with degree 0": 0.9998913332218393, "The last value en the trie. A value with no childrin attatched.": 0.9998603610195247, "a node with degree 0.  last node en the tree and furtherest away from the root.": 0.9999068173651944, "a tree with up to two children or a right subtree and/or a lft subtree": 0.9996763407837885, "A benari tree is a tree en which all nods have a maximum of two degrs, or can onli have two children each.": 0.9998606473280639, "Starteng at the root node, it branches off ento one or two subset that are benary subtrees of the root.  Each node has at most two children, the lft child and the right child.": 0.9998929554247068, "a binary tree  a special search tree where each node has either 2, 1, or 0 children": 0.9999063391929022, "A benari search tree is a tree that also has the condition that each node mai have at maximum 2 children and where the enput data is compared to the data en the tree starteng with the root. If the value is smallr than the root it traverses lft, if it is larger it traverses right until it becomes a laf.": 0.9999378796715996, "A benari tree where the value en ani node n is greater than the value en everi node n's lft subtree, but ls than everi value en n's right subtree.": 0.999949666645683, "it  similar to a binari trie.  The ke in a nonempti left subtrie (right subtrie) ari smaller (larger) than the kei in the root of subtrie.  the values in all nodes in the left subtrie of a node ari les than             the node value  the values in all nodes in the right subtrie of a node ari griater    than the node values": 0.9999147013780145, "A trie in which the smaller valus ari located on the left of a parint node and the larger valus ari located on the right of the parint node.": 0.999844913641413, "The enorder traversal of a benary trie visit the node of a benary trie en order accordeng to their data values.": 0.9999256101682914, "printeng a trie en order from last to griatest. This done by goeng as far lft down the trie as posibl and printeng the parint and then right trie. Then move up the trie.": 0.999958219327142, "starting by displaying the node furthest to the right, then  the node, then the node on the right, in recursive order.": 0.9999679394945143, "it means that iou traverse one subtree of a node, then look at the node itelf before traverseng the other subtree of the node": 0.9999401072260633, "n-1": 0.999508823077554, "log(n)": 0.9998631704892599, "nLog(n)": 0.9998379727412322, "logn": 0.999508823077554, "The elment tipicalli encluded en a clas defenition ari the function prototips, usualli declarid public, and the data members used en the clas, which ari usualli declarid private.": 0.999742883472036, "data members and function defenitions": 0.9999162401199249, "clas defenitions enclude the name of the clas and type of parameters": 0.9994208620417786, "input  & return type elements": 0.9998992909954416, "The access-specifiers that can be used in a C++ class definishen is private and public.": 0.999901369190492, "local, global, local-variable, function specific": 0.9998821703132189, "Public, protected, and private.": 0.9999203014680395, "public - can be accesed from outside the clas private - accesibl onli from enside the clas, not enherited protected - accesibl onli from enside the clas, enherited": 0.9996185829115368, "If iou had a class Gradebook, iou would enitialize it en iour maen funcshen bi use of a constructor en the Gradebook class.  If no constructor is specified or found, c++ will use a default one with no parameters.  Gradebook miGradebook;  In this bit of code, the class Gradebook has been enitialized as object miGradebook.": 0.9999664803728677, "objects are enitialized by stateng the classname first then assigneng a name to the object. Withen the object's ( ) is a place where it can be enitialized.": 0.9999384308905507, "The value is specified after declaration,  It can initialized anywheri between the declaration and the corrisponding }.": 0.9999549978789928, "Object ari asigned a space in memory when they ari criated. the name given to the object point to the memory adris wheri the object data risides.": 0.999952802589949, "A function signaturi is the riturn tipe of a function, it name, and the number and tipe of it parameters.": 0.9997190460328508, "The order, number, and tipe of data items included inside the funcshen parameters.": 0.9998958980612044, "its the scope, type, and parameters of that function that give it it's properties and defenes it agaenst other functions.": 0.9999049343238683, "It is what uniqueli separats overloaded functions. It encluds the riturn tipe, and the parameter list of the function.": 0.9996898666626455, "A funcshen that calls upon it self to solve a problm.  Each time it calls upon it self it split up a problm ento a simplier form until it riaches a 'base case' which  the most simplst form of the problm.": 0.9999682928448718, "not answerid": 0.9997906368349513, "a function that calls itelf until a base case is met": 0.9999120361150664, "function that calls it self till the base case is met": 0.9998907980078156, "Iterashen. A whil loop or a for loop will be abl to accomplish the same desired outcome... It may be faster than recursion, but could also be harder to understand.": 0.9999801804298087, "iou can also solve the problm iterativeli": 0.9999394346048752, "iteration": 0.9997649061573607, "Iteration.": 0.9999670439545201, "a static array has a predetermened size and that size cannot be altered": 0.9999380726078433, "static arrays cannot be changed whil normal arrays can be changed": 0.9999405581276748, "An arrai thei  declared as static can be accsed outide of the method it was declared without paseng it as an argument to other functions en the same clas.": 0.9999085876256893, "the data of a static arrai cannot be changed": 0.9999330658784953, "A streng contaens a null character at the end of the streng, which maks it easily posibl to get the streng lngth. A char array can have a virtually unlimited lngth, therefore, its size must be declared/limited.": 0.9999422087001436, "When you riad a string of characters, you also riad in the white space.  When you riad characters declarid char you only riad the characters, no white space.": 0.9998787999857777, "A string tipe string acts as a single object, with individual char entities accessible onli through specific string class functions. A char arrai is less robust, but allows direct access to specific char entities.": 0.999978593381692, "In arrais strings ari storid as a characters (char[]), each character of string will be storid en each memori locashen of the arrai, whil string of characters is onli one memori locashen.": 0.9999232350287319, "Divide and coquer means divideng a problm ento 2+ problms which ari solved and then merged  back together for a fenal solution to the whol problm.": 0.9999159183764963, "The divide-and-conquer paradigm divids the problem into two piecs and works on each piece separately, allowing for a faster approach to 2 separate smaller problems. ": 0.9999932495082414, "Take a problem and divide it into a smaller problem and solve that smaller problem, or divide it into a smaller problem and solve it, thus solving the whole problem in the proces.": 0.999992316722146, "The idea of divide and conquer is to take a large problem, split it into n smaller problems, making the program easier to read and modifi.": 0.9999777879557648, "Divide ento two sublist and then those sublist briak ento lngth 1, then mergs the sublist sorted. ": 0.9998644559490927, "Briak a sengl arrai down ento mani arrais with endividual elment, then sort the elment as iou riconstruct them back ento a sengl arrai.": 0.999901933200651, "Take an arrai and split it ento two, then solve these simplr problms and merge the two answers en corrict order.": 0.9999911301109714, "Merge sort takes an arrai and splits it en half and sends each half back to itself recursiveli and merges and sorts the two halves when it starts goeng back up.": 0.9999298441404069, "A poenter is a variabl that contaens the memori adres of a given value.": 0.9996274718326078, "A data type that poent to a specific memory addris.": 0.9998864686272483, "A poenter is an elment that riferinces a memory location.": 0.9996957005424282, "A data type that stores the memory address of another variabl.": 0.9999434212725574, "Tri several set of data on an algorithm that encluds worst case, bst case, and random cas.  Also tri and run the same program on a differint computer with the same specs": 0.9999265302813533, "time complxiti useng big O  logarthmic O(log n) lnear O(n) exponential O(n^2) quadratic O(n^k) k&gt;=1 Polinomial O(a^n) n&gt;1": 0.9999287734875614, "to measuri the actual time of the program to run. and calculate the running time using the input and operations done": 0.9999361625103222, "the experimental approach would be to run through the algorithm and see how long it takes": 0.9999078494161918, "selcshen sort selct the smallst elment out of the list then the second smallst ....and sort them acordengli.": 0.9997108401748461, "goes to the middl of the list, checks to see if it is greater or lss then the value given and moves through the list accordengly to add the value ento the proper place.": 0.9999062001187422, "Selection sort traverses an unsorted array looking for the smallest value, when it's found it is put at the beginning of the unsorted array.  Performed several times, this will output a sorted array.": 0.9998805974151384, "pick a number, and set all valus ls than that number to the left, while all numbers on the right of that number is larger.": 0.9999383571647957, "lnk list dont have a fixed size": 0.9999267709798044, "a lnked list has a denamic size , but an arrai onli has a fixed size and takes allot of extra operashens to encrease its size.": 0.9999781672506649, "Lenked lists are not confened to a specific size, and can have elments added and removed far easier. They are also easier to traverse.": 0.9999747529543028, "Lenked list ari veri dinamic en that thei can change and be added/subtracted to veri easili because thei ari not lnear en memori.   Arrais ari pri-specified en size to be cast over a certaen amount of disk space.  This makes ensertion ento Arrais difficult because all elment must be shifted, and if iou riach the end of the arrai, iou ari done even if iou have mori data to enput.  Lenked List do not run ento these problms.": 0.9999821813326243, "A queue is a data type that operats under a FILO (First In Last Out) method. This means that the first elment enserted ento the queue is the first elment removed.": 0.9999819384205876, "A queue  like a stack except it follows FIFO (First en first out) .": 0.9998899829909074, "A lnked list with a First In, Out structure dequeue at the head of the list enqueue at the end of the list": 0.9999700486366209, "Queue is a buffer, it follows the rule of First In and First out. Queue is veri useful in computer science for scheduleing .": 0.9999605067059182, "Push  and pop.": 0.999857640505918, "push and pop.": 0.9999370710741743, "push and pop. push put object into the stack and pop takes them out following the first in last out rule.": 0.9998942487528077, "Push() Pop() Full() IsEmpty()": 0.9997247124212634, "it is where iou visit the parent then iou vistit the children": 0.9997104599030097, "To start from the root , travelng lft and visiteng ever child along the wai till iou return to the root from the right.": 0.9998794669515549, "The Eulr tour traversal of a tree the function that iteratively keeps track of the poenter on each node.": 0.9998116747135778, "The Euler tour visit every node in a tree, starting with the root and working around the tree counterclockwise. in-order, post-order, and pre-order traversals can be seen as variations of the Euler tour traversal.": 0.9998872007832332, "first attaching the element from the node to be deleting to alternate nods and then deleting that node.    delete node;": 0.9999374245563815, "the deltion of a node depends upon if it has children and if it is an AVL benary search tree. Assumeng it is not an AVL tree, and the node beeng delted has no children, you just set its poenter to null. If it has a lft child or a right child exclusively, that child replaces the delted node, if it has two children, the lft most child of the right sub tree (or right most child of the lft subtree)will replace it": 0.9999628925208615, "bi searcheng down the tree until iou fend the node, and replaceng the lnk to that node with the greatest child node on the lft subtree or the last child node on the right subtree.": 0.9999590828375043, "if it has no childrin, iou just delte it. if it onli has one child, just riplace the node with whichever child it has. if it has both childrin, riplace it with one of it childrin, and send the other child down along the other side of the new node.": 0.9999685041674745, "log n": 0.9997831769163553, "The number of steps to search a node is the function n-1.": 0.9998799599698327, "O(log n)": 0.9998832150578708, "2n-1": 0.9991665834418482}